<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Silverfox2016</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Silverfox2016">
<meta property="og:url" content="http://silverfox2016.github.com/index.html">
<meta property="og:site_name" content="Silverfox2016">
<meta property="og:description" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Silverfox2016">
<meta name="twitter:description" content="blog">
  
    <link rel="alternate" href="/atom.xml" title="Silverfox2016" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Silverfox2016</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://silverfox2016.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-让man看起来色彩更加绚丽" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/让man看起来色彩更加绚丽/" class="article-date">
  <time datetime="2017-09-13T09:44:11.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/让man看起来色彩更加绚丽/">让man看起来色彩更加绚丽</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>Man手册</p>
<p>Man手册会为你列出命令和参数的使用大纲，教你如何使用她们。Man手册看起来沉闷呆板。 </p>
<p>你需要安装 ‘most’；她会使你的你的man手册的色彩更加绚丽。</p>
<p>yum install most ( 在epel-release包里）<br>export PAGER=most </p>
<p>使用方法</p>
<p>Quitting: 退出</p>
<p>  Q                      Quit MOST. 退出MOST</p>
<p>  :N,:n                  Quit this file and view next.  退出该文件并查看next</p>
<pre><code>(Use UP/DOWN arrow keys to select next file.)  使用上下箭头键来选择下一个文件
</code></pre><p>Movement: 移动</p>
<p>  SPACE, D              *Scroll down one Screen. 向下滚动一个屏幕。</p>
<p>  U, DELETE             *Scroll Up one screen. 向上滚动一个屏幕。</p>
<p>  RETURN, DOWN          *Move Down one line. 下移动一行</p>
<p>  UP                    <em>Move Up one line. </em>向上移动一行。</p>
<p>  T                      Goto Top of File. 转到文件顶部</p>
<p>  B                      Goto Bottom of file. 转到文件底部</p>
<blockquote>
<p>, TAB                Scroll Window right  滚动窗口最左</p>
</blockquote>
<p>  &lt;                      Scroll Window left  滚动窗口最右</p>
<p>  RIGHT                  Scroll Window left by 1 column 向右滚动1列</p>
<p>  LEFT                   Scroll Window right by 1 column 向左滚动1列</p>
<p>  J, G                   Goto line.  转到xx行</p>
<p>  %                      Goto percent.  转到文件行数百分比</p>
<p>Window Commands: 窗口命令</p>
<p>  Ctrl-X 2, Ctrl-W 2     Split window. 切割窗口</p>
<p>  Ctrl-X 1, Ctrl-W 1     Make only one window.   还原成1个窗口</p>
<p>  O, Ctrl-X O            Move to other window. 移动光标到其它窗口</p>
<p>  Ctrl-X 0               Delete Window.  删除窗口</p>
<p>Searching: 搜索</p>
<p>  S, f, /               *Search forward 搜索关键字</p>
<p>  ?                     *Search Backward 反向搜索</p>
<p>  N                     *Find next in current search direction.   搜索下一个关键字</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/让man看起来色彩更加绚丽/" data-id="cj7iup5gs000cxp5wpy062f1y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx正则说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/nginx正则说明/" class="article-date">
  <time datetime="2017-09-13T08:56:30.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/nginx正则说明/">nginx正则说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>^~     标识符后面跟一个字符串。<br>Nginx将在这个字符串匹配后停止进行正则表达式的匹配（location指令中正则表达式的匹配的结果优先使用）<br>如：location ^~ /images/，你希望对/images/这个目录进行一些特别的操作，如增加expires头，防盗链等，但是你又想把除了这个目录的图片外的所有图片只进行增加expires头的操作，这个操作可能会用到另外一个location，例如：location ~<em> .(gif|jpg|jpeg)$，这样，如果有请求/images/1.jpg，nginx如何决定去进行哪个location中的操作呢？结果取决于标识符^~，如果你这样写：location /images/，这样nginx会将1.jpg匹配到location ~</em> .(gif|jpg|jpeg)$这个location中，这并不是你需要的结果，而增加了^~这个标识符后，它在匹配了/images/这个字符串后就停止搜索其它带正则的location。<br>=      表示精确的查找地址，如location = /它只会匹配uri为/的请求，如果请求为/index.html，将查找另外的location，而不会匹配这个，当然可以写两个location，location = /和location /，这样/index.html将匹配到后者，如果你的站点对/的请求量较大，可以使用这个方法来加快请求的响应速度。<br>@      表示为一个location进行命名，即自定义一个location，这个location不能被外界所访问，只能用于Nginx产生的子请求，主要为error_page和try_files。</p>
<p>~      为区分大小写的匹配。<br>~<em>     不区分大小写的匹配（匹配firefox的正则同时匹配FireFox）。<br>!~     不匹配的<br>!~</em>    不匹配的</p>
<p>.     匹配除换行符以外的任意字符<br>\w     匹配字母或数字或下划线或汉字<br>\s     匹配任意的空白符<br>\d     匹配数字<br>\b     匹配单词的开始或结束<br>^     匹配字符串的开始<br>$     匹配字符串的结束</p>
<ul>
<li>重复零次或更多次</li>
</ul>
<ul>
<li>重复一次或更多次<br>?     重复零次或一次<br>{n}     重复n次<br>{n,}     重复n次或更多次<br>{n,m}     重复n到m次<br>*?     重复任意次，但尽可能少重复<br>+?     重复1次或更多次，但尽可能少重复<br>??     重复0次或1次，但尽可能少重复<br>{n,m}?     重复n到m次，但尽可能少重复<br>{n,}?     重复n次以上，但尽可能少重复</li>
</ul>
<p>\W     匹配任意不是字母，数字，下划线，汉字的字符<br>\S     匹配任意不是空白符的字符<br>\D     匹配任意非数字的字符<br>\B     匹配不是单词开头或结束的位置<br>[^x]     匹配除了x以外的任意字符<br>[^aeiou]     匹配除了aeiou这几个字母以外的任意字符</p>
<p>捕获     (exp)     匹配exp,并捕获文本到自动命名的组里<br>(?<name>exp)     匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)<br>(?:exp)     匹配exp,不捕获匹配的文本，也不给此分组分配组号<br>零宽断言     (?=exp)     匹配exp前面的位置<br>(?&lt;=exp)     匹配exp后面的位置<br>(?!exp)     匹配后面跟的不是exp的位置<br>(?&lt;!exp)     匹配前面不是exp的位置<br>注释     (?#comment)     这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</name></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/nginx正则说明/" data-id="cj7iup5gc0003xp5w3jpgr62l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rsync-log日志时间差8小时问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/rsync-log日志时间差8小时问题/" class="article-date">
  <time datetime="2017-09-13T08:55:40.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/rsync-log日志时间差8小时问题/">rsync log日志时间差8小时问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 用rsync做个单点备份 部署没问题 同步没问题 隔天查看日志<br>发现日志时间差比当前时间差8小时。。。。怀疑时区问题<br>百思不得其解。。。。<br>查看了src的date -R 和 dst的date -R 发现时区均为CST<br>查看hwclock -r src 和 dst 也是一样<br>遂查询rsync源码 额发现是c写的 完全看不懂<br>那么好了 我们查关键字<br>grep time *<br> C library on some systems to fetch the timezone info<br>写的很清楚了 这个是取系统时区。。。到此 卡住。。。<br>遂寻求各种大牛帮助 （根本看不懂C）</p>
<p>最终一大牛帮我看源码 告诉我因为rsync是取chroot下面etc/localtime<br>rsyncd.conf配置文件里面 path路径下etc/localtime 时间<br>如果发现没有取到 那么就会取默认的UTC时间 整整符合我们上面看日志里面发现差的8小时<br>那么 我们给每个path = 路径 下面 创建etc文件目录 在将/etc/localtime 复制到此目录下<br>至此问题解决 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/rsync-log日志时间差8小时问题/" data-id="cj7iup5gi0006xp5wos8qkgbo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-终极Web应用性能和压力测试工具Gor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/终极Web应用性能和压力测试工具Gor/" class="article-date">
  <time datetime="2017-09-13T08:51:39.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/终极Web应用性能和压力测试工具Gor/">终极Web应用性能和压力测试工具Gor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是Gor</p>
<p>项目地址：<a href="https://github.com/buger/gor" target="_blank" rel="external">https://github.com/buger/gor</a></p>
<p>官方描述</p>
<p>Gor is a simple http traffic replication tool written in Go.<br>Its main goal is to replay traffic from production servers to staging and dev environments.</p>
<p>简单点说就是一个http流量复制器，Gor是用Golang写的一个HTTP实时流量复制工具。只需要在LB或者Varnish入口服务器上执行一个进程，就可以把生产环境的流量复制到任何地方，比如Staging 环境、Dev环境。完美解决了HTTP层实时流量复制和压力测试的问题。</p>
<p>Gor的功能</p>
<p>Gor支持流量的放大和缩小、频率限制，这样不需要搭建和生产环境一致的服务器集群也可以正确测试。Gor还支持根据正则表达式过滤流量，这意味着可以单独测试某个API服务。还可以修改HTTP请求头，比如替换User-Agent, 或者增加某些HTTPHeader。</p>
<p>Gor还可以把请求记录到文件，以备回放和分析。Gor支持和ElasticSearch集成，将流量存入ES进行实时分析。</p>
<p>Gor的架构</p>
<p>非http协议的流量复制</p>
<p>对于不是基于http协议的流量复制，可以使用流量复制工具TCPCopy, TCPCopy支持tcp协议流量的复制、转发、拦截，非常棒的工具。</p>
<p>TCPCopy项目地址：<a href="https://github.com/session-replay-tools/tcpcopy" target="_blank" rel="external">https://github.com/session-replay-tools/tcpcopy</a></p>
<p>Gor安装</p>
<p>二进制版本</p>
<p>官方预编译版本使用比较简单，开箱即用。</p>
<p>通过以下地址下载最新版本</p>
<p><a href="https://github.com/buger/gor/releases" target="_blank" rel="external">https://github.com/buger/gor/releases</a> </p>
<p>Linux</p>
<p>$ wget <a href="https://github.com/buger/gor/releases/download/v0.12.1/gor_0.12.1_x64.tar.gz$" target="_blank" rel="external">https://github.com/buger/gor/releases/download/v0.12.1/gor_0.12.1_x64.tar.gz$</a> tar xzvf gor_0.12.1_x64.tar.gz$ cp gor /usr/local/bin<br>Mac</p>
<p>$ wget <a href="https://github.com/buger/gor/releases/download/v0.12.1/gor_0.12.1_mac.tar.gz$" target="_blank" rel="external">https://github.com/buger/gor/releases/download/v0.12.1/gor_0.12.1_mac.tar.gz$</a> tar xzvf gor_0.12.1_mac.tar.gz<br>编译安装</p>
<p>搭建标准的Go语言环境,可参考<a href="http://golang.org/doc/code.html。并设置$GOPATH环境变量" target="_blank" rel="external">http://golang.org/doc/code.html。并设置$GOPATH环境变量</a></p>
<p>获取源代码</p>
<p>$ go get github.com/buger/gor<br>编译</p>
<p>$ cd $GOPATH/src/github.com/buger/gor$ go build<br>编译完成会产生一个gor二进制文件。</p>
<p>Gor配置参数</p>
<p>gor –help<br>-cpuprofile string<br>        write cpu profile to file<br>-debug verbose<br>        打开debug模式，显示所有接口的流量<br>  -http-allow-header value<br>        用一个正则表达式来匹配http头部，如果请求的头部没有匹配上，则被拒绝<br>         gor –input-raw :8080 –output-http staging.com –http-allow-header api-version:^v1 (default [])<br>  -http-allow-method value<br>        类似于一个白名单机制来允许通过的http请求方法，除此之外的方法都被拒绝.<br>        gor –input-raw :8080 –output-http staging.com –http-allow-method GET –http-allow-method OPTIONS (default [])<br>  -http-allow-url value<br>        一个正则表达式用来匹配url， 用来过滤完全匹配的的url，在此之外的都被过滤掉<br>         gor –input-raw :8080 –output-http staging.com –http-allow-url ^www. (default [])<br>  -http-disallow-header value<br>        用一个正则表达式来匹配http头部，匹配到的请求会被拒绝掉<br>         gor –input-raw :8080 –output-http staging.com –http-disallow-header “User-Agent: Replayed by Gor” (default [])<br>  -http-disallow-url value<br>        用一个正则表达式来匹配url，如果请求匹配上了，则会被拒绝<br>         gor –input-raw :8080 –output-http staging.com –http-disallow-url ^www. (default [])<br>  -http-header-limiter value<br>        读取请求，基于FNV32-1A散列来拒绝一定比例的特殊请求<br>         gor –input-raw :8080 –output-http staging.com –http-header-imiter user-id:25% (default [])<br>  -http-original-host<br>        在–output-http的输出中，通常gor会使用取代请求的http头，所以应该禁用该选项，保留原始的主机头<br>  -http-param-limiter value<br>        Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A hash of a specific GET param:<br>         gor –input-raw :8080 –output-http staging.com –http-param-limiter user_id:25% (default [])<br>  -http-rewrite-url value<br>        Rewrite the request url based on a mapping:<br>        gor –input-raw :8080 –output-http staging.com –http-rewrite-url /v1/user/([^\/]+)/ping:/v2/user/$1/ping (default [])<br>  -http-set-header value<br>        Inject additional headers to http reqest:<br>        gor –input-raw :8080 –output-http staging.com –http-set-header ‘User-Agent: Gor’ (default [])<br>  -http-set-param value<br>        Set request url param, if param already exists it will be overwritten:<br>        gor –input-raw :8080 –output-http staging.com –http-set-param api_key=1 (default [])<br>  -input-dummy value<br>        Used for testing outputs. Emits ‘Get /‘ request every 1s (default [])<br>  -input-file value<br>        从一个文件中读取请求<br>        gor –input-file ./requests.gor –output-http staging.com (default [])<br>  -input-http value<br>        从一个http接口读取请求</p>
<pre><code># Listen for http on 9000
gor --input-http :9000 --output-http staging.com (default [])
</code></pre><p>  -input-raw value<br>        Capture traffic from given port (use RAW sockets and require <em>sudo</em> access):</p>
<pre><code># Capture traffic from 8080 port
gor --input-raw :8080 --output-http staging.com (default [])
</code></pre><p>  -input-tcp value<br>       用来在多个gor之间流转流量</p>
<pre><code># Receive requests from other Gor instances on 28020 port, and redirect output to staging
gor --input-tcp :28020 --output-http staging.com (default [])
</code></pre><p>  -memprofile string<br>        write memory profile to this file<br>  -middleware string<br>        Used for modifying traffic using external command<br>  -output-dummy value<br>        用来测试输入，打印出接收的数据. (default [])<br>  -output-file value<br>        把进入的请求写入一个文件中<br>        gor –input-raw :80 –output-file ./requests.gor (default [])<br>  -output-http value<br>        转发进入的请求到一个http地址上</p>
<pre><code># Redirect all incoming requests to staging.com address 
gor --input-raw :80 --output-http http://staging.com (default [])
</code></pre><p>  -output-http-elasticsearch string<br>        把请求和响应状态发送到ElasticSearch:<br>        gor –input-raw :8080 –output-http staging.com –output-http-elasticsearch ‘es_host:api_port/index_name’<br>  -output-http-redirects int<br>        设置多少次重定向被允许<br>  -output-http-stats<br>        每5秒钟输出一次输出队列的状态<br>  -output-http-timeout duration<br>       指定http的request/response超时时间，默认是5秒<br>  -output-http-workers int<br>        gor默认是动态的扩展工作者数量，你也可以指定固定数量的工作者<br>  -output-tcp value<br>        用来在多个gor之间流转流量</p>
<pre><code># Listen for requests on 80 port and forward them to other Gor instance on 28020 port
gor --input-raw :80 --output-tcp replay.local:28020 (default [])
</code></pre><p>  -output-tcp-stats<br>        每5秒钟报告一次tcp输出队列的状态<br>  -split-output true<br>        By default each output gets same traffic. If set to true it splits traffic equally among all outputs.<br>  -stats<br>        打开输出队列的状态<br>  -verbose<br>        Turn on more verbose output<br>Gor常用命令</p>
<p>简单的HTTP流量复制</p>
<p>$ gor –input-raw :80 –output-http “<a href="http://staging.com" target="_blank" rel="external">http://staging.com</a>“<br>HTTP流量复制频率控制(获取每秒超过10个请求)</p>
<p>$ gor –input-tcp :28020 –output-http “<a href="http://staging.com|10" target="_blank" rel="external">http://staging.com|10</a>“<br>HTTP流量复制缩小</p>
<p>$ gor –input-raw :80 –output-tcp “replay.local:28020|10%”<br>HTTP流量记录到本地文件</p>
<p>$ gor –input-raw :80 –output-file requests.gor<br>HTTP流量回放和压测</p>
<p>$ gor –input-file “requests.gor|200%” –output-http “staging.com”<br>HTTP流量过滤复制</p>
<p>$ gor –input-raw :8080 –output-http staging.com –output-http-url-regexp ^www.<br>自定义一些流量复制的参数</p>
<p>$ gor –input-raw :80 –output-http 192.168.2.6:8000 –http-allow-method POST –http-set-header ‘User-Agent: Gor’ -output-http-workers=1 -http-allow-url test.php<br>将流量复制两份到不同的测试服务</p>
<p>$ gor –input-tcp :28020 –output-http “<a href="http://staging.com" target="_blank" rel="external">http://staging.com</a>“  –output-http “<a href="http://dev.com" target="_blank" rel="external">http://dev.com</a>“<br>将流量像负载均衡一样分配到不同的服务器</p>
<p>$ gor –input-tcp :28020 –output-http “<a href="http://staging.com" target="_blank" rel="external">http://staging.com</a>“  –output-http “<a href="http://dev.com" target="_blank" rel="external">http://dev.com</a>“ –split-output true<br>测试实例</p>
<p>预发布系统压力测试</p>
<p>预发布系统主要由预发布服务器和Gor流量复制工具组成，为了查看和分析测试效果，还可以接入各种监控分析系统。<br>部署搭建预发布服务，预发布服务使用的数据库，消息队列，缓存等等需要生成环境隔离，避免对生产环境造成影响；同时，预发布环境使用的数据尽量保证和生成环境一致，以保证测试效果。<br>将线上的五台Api服务器的流量复制到了一台preview(预发布)服务器</p>
<p>在Api服务器上启动Gor Listener，复制80端口的流量，转发到预发布服务器的28020端口<br>$ sudo gor –input-raw :80 –output-tcp preview:28020<br>在预发布服务器上启动Gor Replayer， 监听28020端口，同时将请求转发到预发布服务器<br>$ sudo gor –input-tcp preview:28020 –output-http <a href="http://staging.com" target="_blank" rel="external">http://staging.com</a><br>也可以将listener和replayer合二为一<br>$ sudo gor –input-tcp preview:28020 –output-http <a href="http://staging.com" target="_blank" rel="external">http://staging.com</a><br>注: gor使用listener捕捉请求的时候需要sudo权限</p>
<p>测试总结<br>极少的情况下Gor会有少量的丢包问题出现，但是不影响测试效果。<br>建议将Gor的listener和replayer分开，减少对生成环境性能的影响。<br>部署搭建预发布服务，预发布服务使用的数据库，消息队列，缓存等等需要生成环境隔离，避免对生产环境造成影响；同时，预发布环境使用的数据尽量保证和生成环境一致，以保证测试效果。<br>由于预发布环境和生成环境的数据无法做到实时的同步，所以要注意区分哪些错误是有程序的bug，哪些是由数据不一致导致的。<br>预发布系统能够一站解决回归测试、abtest和压力测试，然而还是会有局限性：对于比较复杂的业务逻辑，并不能直观的表现出来，需要后台对数据进行进一步的分析比较后才能判断。</p>
<p>参考文档</p>
<p><a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a><br><a href="https://github.com/buger/gor" target="_blank" rel="external">https://github.com/buger/gor</a><br><a href="https://blog.eood.cn/web-performance-testing-gor" target="_blank" rel="external">https://blog.eood.cn/web-performance-testing-gor</a><br><a href="http://my.oschina.net/guol/blog/675294" target="_blank" rel="external">http://my.oschina.net/guol/blog/675294</a><br><a href="http://xuyaoqiang.com/2016/05/02/prevew-api-based-on-gor/" target="_blank" rel="external">http://xuyaoqiang.com/2016/05/02/prevew-api-based-on-gor/</a><br><a href="https://github.com/buger/gor/blob/master/ELASTICSEARCH.md" target="_blank" rel="external">https://github.com/buger/gor/blob/master/ELASTICSEARCH.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/终极Web应用性能和压力测试工具Gor/" data-id="cj7iup5gq000bxp5whmyfhesu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-高效用Google" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/高效用Google/" class="article-date">
  <time datetime="2017-09-13T08:50:46.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/高效用Google/">高效用Google</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 如果票选近二十年最伟大的发明，我相信搜索引擎肯定会占据一个不容小觑的位置，它不单是一项发明，更是一项成就，最大程度消灭了信息的不平等。既然人人都可以接触到海量的信息，那么衡量信息财富多寡就只剩下技巧这惟一的标准了：善用搜索引擎的都是信息时代的富翁，不懂搜索引擎的都是信息时代的负翁。<br>而像程序员这种必须终生学习的职业，搜索引擎就是我们的左膀右臂。懂搜索引擎就是我们的基本功，不，应该是童子功。只是大部分新手都在过分粗放的使用搜索引擎，而花几分钟时间了解搜索引擎的技巧和语法，就能让自己的信息财富来一个大跃进，不也是一笔划算的买卖么。</p>
<p>而对于技术类问题的检索，谷歌的表现水准无疑要甩百度几条街；所以善用搜索引擎的第一条原则必然是：一如既往毫不犹豫百折不挠的使用Google。而对于一名程序员来说，保证自己随时随地能访问Google，是最最基本的技能，哪怕花费少许金钱也是物超所值。那么以下就撇开百度、专门讲讲使用Google的小贴士。</p>
<p>完整匹配<br>在Google的输入框里，所有的空格都被理解为加号。如果你输入的是mysql foreign key，那么返回的搜索结果里也许既有mysql存在，也有foreign key存在，但不一定有mysql foreign key存在。另外，过分常用的、单独存在没有意义的词汇往往被忽略掉，比如the/a/that等等。</p>
<p>如果你想要找含有mysql foreign key这个词组的文章，那么你必须在搜索词前后加上引号，输入”mysql foreign key”，不管你输入的时候使用的是全角字符（“或者”）还是半角字符（”），Google都照样能够正确处理。这就是引号的作用：返回完整匹配的结果。</p>
<p>筛选<br>为了进一步筛选搜索结果，还需要学会另外一个符号 — 减号（-）。比如，”mysql foreign key” - “nodejs”就要求Google返回含有mysql foreign key但不存在nodejs的文章。</p>
<p>通配符<br>另外一个程序员耳熟能详的符号是正则里最常露脸的星号，看到星号就下意识的想到通配符，在Google的搜索规则中也是如此，输入”mysql connect error *”就会返回所有已知的关于MySQL连接错误的文章。</p>
<p>站内搜索<br>最后推荐一个威力无穷的语法，让你有机会再对搜索结果做一次筛选。比如针对程序员查bug，stackoverflow是我个人觉得可信度最高也最全面的一个网站，所以我就经常使用site的魔法，像”mysql foreign key” site:stackoverflow.com就会返回对应网站内所有关于mysql foreign key的文章。</p>
<p>语言和日期<br>像2shou叔这种英语阅读能力不过关的人，遇到急事就不能一篇篇翻原版文档了，不得不求助国内的二手货；这时，Google界面上的一个小按钮就帮上大忙了：点击搜索工具 - 不限语言，下拉选择所有简体中文网页，一下子就回到了祖国母亲的怀抱。有时用新出的库版本，别忘了隔壁那个不限日期按钮，可以帮你找到最最新鲜的技术文章。</p>
<p>Tab，以及宅男福利<br>只限Chrome的一招：输入某个网址，再点击Tab，会能直接使用这个站点的站内搜索了，比别人快个几秒，关键时刻也很管用不是么。</p>
<p>最后留个福利吧，曾经被人偷偷问过，谷歌的安全搜索怎么关闭；网上有一些繁复的攻略，对我们程序员，搜索网址加个参数：&amp;safe=off，一招就可日天。</p>
<p>祝大家Google快乐。</p>
<p>附：Google搜索命令大全</p>
<p>1、双引号</p>
<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和Google 都支持这个指令。例如搜索： “seo方法图片”</p>
<p>2、减号</p>
<p>减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和bd都支持这个指令。<br>例如：搜索 -引擎<br>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</p>
<p>3、星号<br>星号是常用的通配符，也可以用在搜索中。百度不支持号搜索指令。<br>比如在Google 中搜索：搜索擎<br>其中的号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p>
<p>4、inurl<br>inurl: 指令用于搜索查询词出现在url 中的页面。bd和Google 都支持inurl 指令。inurl 指令支持中文和英文。<br>比如搜索：inurl:搜索引擎优化</p>
<p>返回的结果都是网址url 中包含“搜索引擎优化”的页面。由于关键词出现在url 中对排名有一定影响，使用inurl:搜索可以更准确地找到竞争对手。</p>
<p>5、inanchor<br>inanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。<br>比如在Google 搜索 ：inanchor:点击这里<br>返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。<br>可以用来找到某个关键词的竞争对收，而且这些竞争对手往往是做过SEO 的。研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</p>
<p>6、intitle<br>intitle: 指令返回的是页面title 中包含关键词的页面。Google 和bd都支持intitle 指令。<br>使用intitle 指令找到的文件是更准确的竞争页面。如果关键词只出现在页面可见文字中，而没有出现在title 中，大部分情况是并没有针对关键词进行优化，所以也不是有力的竞争对手。</p>
<p>7、allintitle<br>allintitle:搜索返回的是页面标题中包含多组关键词的文件。<br>例如 ：allintitle:SEO 搜索引擎优化<br>就相当于：intitle:SEO intitle:搜索引擎优化<br>返回的是标题中中既包含“SEO”，也包含“搜索引擎优化”的页面</p>
<p>8、allinurl<br>与allintitle: 类似。<br>allinurl:SEO 搜索引擎优化<br>就相当于 ：inurl:SEO inurl:搜索引擎优化</p>
<p>9、filetype<br>用于搜索特定文件格式。Google 和bd都支持filetype 指令。<br>比如搜索filetype:pdf SEO<br>返回的就是包含SEO 这个关键词的所有pdf 文件。</p>
<p>10、site<br>site:是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。</p>
<p>11、linkdomain<br>linkdomain:指令只适用于雅虎，返回的是某个域名的反向链接。雅虎的反向链接数据还比较准<br>确，是SEO 人员研究竞争对手外部链接情况的重要工具之一。<br>比如搜索</p>
<p>linkdomain:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a> -site:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a></p>
<p>得到的就是点石网站的外部链接，因为-site:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a> 已经排除了点石本身的页面，也就是内部<br>链接，剩下的就都是外部链接了。</p>
<p>12、related<br>related:指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索</p>
<p>related:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a></p>
<p>我们就可以得到Google 所认为的与点石网站有关联的其他页面。 这种关联到底指的是什么，Google 并没有明确说明，一般认为指的是有共同外部链接的网站。</p>
<p>上面介绍的这几个高级搜索指令，单独使用可以找到不少资源，或者可以更精确地定位竞争对<br>手。把这些指令混合起来使用则更强大。</p>
<p>inurl:gov 减肥</p>
<p>返回的就是url 中包含gov，页面中有“减肥”这个词的页面。很多SEO 人员认为GVM和学校网<br>站有比较高的权重，找到相关的GVM和学校网站，就找到了最好的链接资源。</p>
<p>下面这个指令返回的是来自.中国教育和科研计算机网CERNET，也就是学校域名上的包含“交换链接”这个词的页面：</p>
<p>inurl:.中国教育和科研计算机网CERNET 交换链接</p>
<p>从中SEO 人员可以找到愿意交换链接的学校网站。</p>
<p>或者使用一个更精确的搜索：</p>
<p>inurl:.中国教育和科研计算机网CERNET intitle:交换链接</p>
<p>返回的则是来自中国教育和科研计算机网CERNET 域名，标题中包含“交换链接”这四个字的页面，返回的结果大部分应<br>该是愿意交换链接的学校网站。</p>
<p>再比如下面这个指令：</p>
<p>inurl:中国教育和科研计算机网CERNET*register</p>
<p>返回的结果是在.中国教育和科研计算机网CERNET 域名上，url 中包含“forum”以及“register”这两个单词的页面，也就是<br>学校论坛的注册页面。找到这些论坛，也就找到了能在高权重域名上留下签名的很多机会。</p>
<p>下面这个指令返回的是页面与减肥有关，url 中包含links 这个单词的页面：</p>
<p>减肥 inurl:links</p>
<p>很多站长把交换链接页面命名为links.html 等，所以这个指令返回的就是与减肥主题相关的交换<br>链接页面。</p>
<p>下面这个指令返回的是url 中包含<a href="http://gov.cn" target="_blank" rel="external">http://gov.cn</a> 以及links 的页面，也就是GVM域名上的交换链接页面：</p>
<p>allinurl:gov.cn+links</p>
<p>最后一个例子，在雅虎搜索这个指令：</p>
<p>linkdomain:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a> -linkdomain:<a href="http://cnseotool.com" target="_blank" rel="external">http://cnseotool.com</a><br>返回的是链接到点石网站，却没有链接到我的博客的网站。使用这个指令可以找到很多连向你<br>的竞争对手或其他同行业网站，却没连向你的网站的页面，这些网站是最好的链接资源。<br>高级搜索指令组合使用变化多端，功能强大。一个合格的SEO必须熟练掌握这几个常用指令的<br>意义及组合方法，才能更有效率地找到更多竞争对手和链接资源。</p>
<p>找外链的时候你可以用这几种命令组合，例如site:.com inurl:blog “post a comment” -”comments closed” -”you must be logged in” “输入你的关键词“，<br>site:.com 是 指， 只显示.com的网站。 如果你想要 org的链接，就换成 site:.org，inurl:blog 是指博客。<br>“post a comment” -”comments closed” -”you must be logged in” 是指， “能够写评论的” 减去“ 关闭评论的” 再减去“ 必须要登录才能写评论的”。</p>
<p>一个我最喜欢的Google搜索技巧的清单</p>
<p>link:URL = 列出到链接到目标URL的网页清单.<br>related:URL = 列出于目标URL地址有关的网页.<br>site:Domain Name Registration and Web Hosting 搜索区域仅限于目标网站.<br>allinurl:WORDS = 只显示在URL地址里有搜索结果的页面.<br>inurl:WORD = 跟allinurl类似,但是只在URL中搜索第一个词.<br>allintitle:WORD = 搜索网页标题.<br>intitle:WORD = 跟allintitle类似,但是只在标题里搜索第一个词.<br>cache:URL = 将显示关于URL的Google缓存(中国不可用).<br>info:URL = 将显示一个包含了这些元素的页面:类似结果的链接,反向链接,还有包括了这个URL的页面.在搜索框里直接输入URL会起到同样的效果.<br>filetype:SOMEFILETYPE = 指定文件类型.<br>-filetype:SOMEFILETYPE = 剔除指定文件类型.<br>site:Welcome to SomeSite.Net ! “+Welcome to SomeSite.Net !” = 显示该站点有多少网页被google收录<br>allintext: = 搜索文本,但不包括网页标题和链接<br>allinlinks: = 搜索链接, 不包括文本和标题<br>WordA OR WordB = 搜索包含两关键词之一的页面<br>“Word” OR “Phrase” = 精确的要求搜索单词或者句子<br>WordA -WordB = 包含单词A但是不包含单词B<br>WordA +WordB = 都包含<br>~WORD = 寻找此单词和它的同义词<br>~WORD-WORD = 只搜索同义词,不要原词</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/高效用Google/" data-id="cj7iup5gx000exp5ws5z9sz5w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux下使用Rinetd来实现端口转发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/Linux下使用Rinetd来实现端口转发/" class="article-date">
  <time datetime="2017-09-13T08:48:15.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/Linux下使用Rinetd来实现端口转发/">Linux下使用Rinetd来实现端口转发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Linux下端口转发一般都使用iptables来实现，使用iptables可以很容易将TCP和UDP端口从防火墙转发到内部主机上。但是如果需要将流量从专用地址转发到不在您当前网络上的机器上，可尝试另一个应用层端口转发程序Rinetd。Rinetd短小、高效，配置起来比iptables也简单很多。<br>Rinetd是为在一个Unix和Linux操作系统中为重定向传输控制协议(TCP)连接的一个工具。Rinetd是单一过程的服务器，它处理任何数量的连接到在配置文件etc/rinetd中指定的地址/端口对。尽管rinetd使用非闭锁I/O运行作为一个单一过程，它可能重定向很多连接而不对这台机器增加额外的负担。</p>
<p>安装</p>
<p>通过包安装<br>CentOS</p>
<p>官方源中不具有Rinetd，所以需要先安装三方源。</p>
<p>配置三方源</p>
<p>32位系统</p>
<p>$ vim /etc/yum.repos.d/nux-misc.repo[nux-misc]name=Nux Miscbaseurl=<a href="http://li.nux.ro/download/nux/misc/el6/i386/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro" target="_blank" rel="external">http://li.nux.ro/download/nux/misc/el6/i386/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</a><br>64位系统</p>
<p>$ vim  /etc/yum.repos.d/nux-misc.repo:[nux-misc]name=Nux Miscbaseurl=<a href="http://li.nux.ro/download/nux/misc/el6/x86_64/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro" target="_blank" rel="external">http://li.nux.ro/download/nux/misc/el6/x86_64/enabled=0gpgcheck=1gpgkey=http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.ro</a><br>安装Rinetd</p>
<p>$ yum –enablerepo=nux-misc install rinetd<br>Ubuntu</p>
<p>$ apt-get install rinetd<br>编译安装<br>$ wget <a href="http://www.boutell.com/rinetd/http/rinetd.tar.gz$" target="_blank" rel="external">http://www.boutell.com/rinetd/http/rinetd.tar.gz$</a> mkdir  -p /usr/man/man8   #默认会把man文件放么/usr/man/man8下面，如果没有这个目录会报目前不存在，但不影响使用. $ make &amp;&amp; make install<br>配置</p>
<p>配置端口转发的配置文件在/etc/rinetd.conf</p>
<p>配置文件格式</p>
<p>[bindaddress] [bindport] [connectaddress] [connectport]绑定的地址    绑定的端口  连接的地址      连接的端口[Source Address] [Source Port] [Destination Address] [Destination Port]源地址            源端口         目的地址               目的端口<br>在每一单独的行中指定每个要转发的端口。源地址和目的地址都可以是主机名或IP地址，IP 地址0.0.0.0将rinetd绑定到任何可用的本地IP地址上。例如：0.0.0.0 8080 www.hi-linux.com 80</p>
<p>配置规则</p>
<p>$ vim /etc/rinetd.conf0.0.0.0 8080 172.19.94.3 80800.0.0.0 2222 192.168.0.103 33891.2.3.4 80 192.168.0.10 80allow <em>.</em>.<em>.</em>logfile /var/log/rinetd.log<br>说明</p>
<p>0.0.0.0表示本机绑定所有可用地址<br>将所有发往本机8080端口的请求转发到172.19.94.3的8080端口<br>将所有发往本机2222端口的请求转发到192.168.0.103的3389端口<br>将所有发往1.2.3.4的80端口请求转发到192.168.0.10的80端口<br>allow设置允许访问的ip地址信息,<em>.</em>.<em>.</em>表示所有IP地址<br>logfil设置打印的log的位置</p>
<p>运行</p>
<p>启动Rinetd<br>脚本启动</p>
<p>$ /etc/init.d/rinetd start<br>手动启动</p>
<p>编译安装不自带脚本</p>
<p>$ /usr/sbin/rinetd -c /etc/rinetd.conf<br>关闭rinetd<br>脚本关闭</p>
<p>$ /etc/init.d/rinetd stop<br>手动关闭</p>
<p>编译安装不自带脚本</p>
<p>$ pkill rinetd<br>注意事项<br>1.rinetd.conf中绑定的本机端口必须没有被其它程序占用<br>2.运行rinetd的系统防火墙应该打开绑定的本机端口<br>3.不支持FTP的跳转</p>
<p>参考文档</p>
<p><a href="https://www.douban.com/note/527117358/" target="_blank" rel="external">https://www.douban.com/note/527117358/</a><br><a href="http://pvbutler.blog.51cto.com/7662323/1621753" target="_blank" rel="external">http://pvbutler.blog.51cto.com/7662323/1621753</a><br><a href="http://blog.csdn.net/wang7dao/article/details/8498530" target="_blank" rel="external">http://blog.csdn.net/wang7dao/article/details/8498530</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/Linux下使用Rinetd来实现端口转发/" data-id="cj7iup5g30000xp5wf6zg0u3x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开启ControlPersist来大幅度提升SSH的连接速度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/开启ControlPersist来大幅度提升SSH的连接速度/" class="article-date">
  <time datetime="2017-09-13T08:44:43.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/开启ControlPersist来大幅度提升SSH的连接速度/">开启ControlPersist来大幅度提升SSH的连接速度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>背景介绍：<br>目前，项目中服务器的配置管理已经全部从Puppet迁移到了Ansible，而之前一直认为不会带来困扰的SSH通道慢的问题则暴露的很明显了。<br>因为很多时候需要同时更新几百台服务器，有不少服务器与Ansible主机还不在同一个IDC机房。<br>无意间发现了一篇文章，提到开启SSH的ControlMaster并持久化socket连接，可以加速Ansible的执行速度，不需要在每次都经历SSH认证，单个服务器可能节约的时间仅在1秒左右，而上百台的服务器就能节省约1分钟左右的时间。</p>
<p>但开启这个功能，必须安装版本较新的openssh，而我们大部分主机都是CentOS6.4 x86_64，默认的版本太旧了并且官方yum仓库中的版本也很旧。<br>考虑到这个功能仅需要客户端的支持即可，不需要在每台服务器上都安装，我们就下载了最新的openssh源码包并打包成了RPM直接安装到了Ansible操作主机上。</p>
<p>服务器环境：<br>CentOS 6.4 x86_64 Minimal</p>
<ol>
<li>编译生成OpenSSH RPM<br>1.1 安装编译所需工具<br>$ sudo yum -y groupinstall “Development tools”<br>$ sudo yum -y install pam-devel rpm-build rpmdevtools zlib-devel krb5-devel tcp_wrappers tcp_wrappers-devel tcp_wrappers-libs</li>
</ol>
<p>1.2 配置RPM编译环境<br>$ cd /home/dong.guo<br>$ mkdir rpmbuild<br>$ cd rpmbuild<br>$ mkdir -pv {BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS,TMP}</p>
<p>$ cd /home/dong.guo<br>$ vim .rpmmacros</p>
<p>1<br>%_topdir /home/dong.guo/rpmbuild<br>2<br>%_tmppath /home/dong.guo/TMP<br>1.3 升级OpenSSL到最新<br>$ sudo yum update openssl</p>
<p>1.4 编译OpenSSH RPM<br>1.4.1 下载源码包<br>$ cd /home/dong.guo/rpmbuild/SOURCES/<br>$ wget <a href="http://mirror.team-cymru.org/pub/OpenBSD/OpenSSH/portable/openssh-6.6p1.tar.gz" target="_blank" rel="external">http://mirror.team-cymru.org/pub/OpenBSD/OpenSSH/portable/openssh-6.6p1.tar.gz</a><br>$ wget <a href="http://mirror.team-cymru.org/pub/OpenBSD/OpenSSH/portable/openssh-6.6p1.tar.gz.asc" target="_blank" rel="external">http://mirror.team-cymru.org/pub/OpenBSD/OpenSSH/portable/openssh-6.6p1.tar.gz.asc</a><br>$ openssl dgst -sha1 openssh-6.6p1.tar.gz; echo b850fd1af704942d9b3c2eff7ef6b3a59b6a6b6e</p>
<p>1.4.2 配置SPEC文件<br>$ cd /home/dong.guo/rpmbuild/SPECS<br>$ tar xfz ../SOURCES/openssh-6.6p1.tar.gz openssh-6.6p1/contrib/redhat/openssh.spec<br>$ mv openssh-6.6p1/contrib/redhat/openssh.spec openssh-6.6p1.spec<br>$ rm -rf openssh-6.6p1<br>$ sudo chown 74:74 openssh-6.6p1.spec<br>$ sed -i -e “s/%define no_gnome_askpass 0/%define no_gnome_askpass 1/g” openssh-6.6p1.spec<br>$ sed -i -e “s/%define no_x11_askpass 0/%define no_x11_askpass 1/g” openssh-6.6p1.spec<br>$ sed -i -e “s/BuildPreReq/BuildRequires/g” openssh-6.6p1.spec</p>
<p>1.4.3 编译生成RPM<br>$ cd /home/dong.guo/rpmbuild/SPECS<br>$ rpmbuild -ba openssh-6.6p1.spec</p>
<p>1.4.4 查看生成的RPM<br>$ cd /home/dong.guo/rpmbuild/RPMS/x86_64<br>$ ls openssh-*</p>
<p>1<br>openssh-6.6p1-1.x86_64.rpm  openssh-clients-6.6p1-1.x86_64.rpm  openssh-debuginfo-6.6p1-1.x86_64.rpm  openssh-server-6.6p1-1.x86_64.rpm<br>1.4.5 安装生成的RPM<br>$ cd /home/dong.guo/rpmbuild/RPMS/x86_64<br>$ sudo rpm -e openssh-askpass<br>$ sudo rpm -e openssh-ldap<br>$ sudo rpm -Fvh openssh<em>6.6p1-1</em>rpm</p>
<p>1<br>Preparing…          ########################################### [100%]<br>2<br>   1:openssh          ########################################### [ 33%]<br>3<br>   2:openssh-clients  ########################################### [ 67%]<br>4<br>   3:openssh-server   warning: /etc/ssh/sshd_config created as /etc/ssh/sshd_config.rpmnew ##################################### [100%]<br>1.4.6 更新SSH配置文件，避免某些参数变更造成无法远程登录<br>$ sudo cp /etc/ssh/sshd_config.rpmnew /etc/ssh/sshd_config<br>$ sudo /etc/init.d/sshd restart</p>
<p>1.4.7 查看已安装的RPM<br>$ sudo rpm -qa | grep openssh<br>openssh-clients-6.6p1-1.x86_64<br>openssh-server-6.6p1-1.x86_64<br>openssh-6.6p1-1.x86_64</p>
<ol>
<li>配置ControlMaster<br>$ cd /home/dong.guo<br>$ vim .ssh/config</li>
</ol>
<p>1<br>Host *<br>2<br>  Compression yes<br>3<br>  ServerAliveInterval 60<br>4<br>  ServerAliveCountMax 5<br>5<br>  ControlMaster auto<br>6<br>  ControlPath ~/.ssh/sockets/%r@%h-%p<br>7<br>  ControlPersist 4h</p>
<ol>
<li><p>下载cmc工具用于管理sockets<br>$ cd ~<br>$ sudo yum install <a href="http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm" target="_blank" rel="external">http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</a><br>$ sudo yum install git<br>$ cd /home/dong.guo<br>$ mkdir bin<br>$ git clone <a href="https://github.com/ClockworkNet/cmc.git" target="_blank" rel="external">https://github.com/ClockworkNet/cmc.git</a><br>$ cp cmc/cmc bin/</p>
</li>
<li><p>使用与测试<br>4.1 查看当前的sockets<br>$ cmc -l</p>
</li>
</ol>
<p>1<br>No ControlMaster connection sockets found.<br>4.2 统计第一次的执行时间<br>$ time ssh rainbow@heylinux.com ‘hostname -s’</p>
<p>1<br>ec2-tokyo<br>2</p>
<p>3<br>real    0m9.486s<br>4<br>user    0m0.017s<br>5<br>sys 0m0.015s<br>耗时9.5秒</p>
<p>4.3 查看当前的sockets<br>$ cmc -l</p>
<p>1<br>heylinux.com<br>2<br>  Master running (pid=32857, cmd=ssh: /home/dong.guo/.ssh/sockets/rainbow@heylinux.com-22 [mux], start=19:19:05)<br>3<br>  Socket: /home/dong.guo/.ssh/sockets/rainbow@heylinux.com-22<br>4.4 统计有socket情况下的执行时间<br>$ time ssh rainbow@heylinux.com ‘hostname -s’</p>
<p>1<br>ec2-tokyo<br>2</p>
<p>3<br>real    0m0.240s<br>4<br>user    0m0.004s<br>5<br>sys 0m0.005s<br>耗时0.24秒</p>
<p>4.5 删除当前所有的sockets<br>$ cmc -X</p>
<p>1<br>heylinux.com - Closing ControlMaster connection<br>2<br>  Exit request sent.<br>4.6 统计没有socket情况下的执行时间<br>$ time ssh rainbow@heylinux.com ‘hostname -s’</p>
<p>1<br>ec2-tokyo<br>2</p>
<p>3<br>real    0m9.468s<br>4<br>user    0m0.016s<br>5<br>sys 0m0.017s<br>仍然是9.5秒</p>
<ol>
<li>结论<br>在开启了ControlMaster的持久化之后，SSH在建立了sockets之后，节省了每次验证和创建连接的时间。<br>在网络状况不是特别理想，尤其是跨互联网的情况下，所带来的性能提升是非常可观的，在上面的测试中节约了9秒。<br>而即使在局域网内部使用，每台服务器节省1秒左右的时间，同时操作上百台服务器时，节省的时间也是非常可观的，非常值得拥有。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/开启ControlPersist来大幅度提升SSH的连接速度/" data-id="cj7iup5gn0009xp5w24n64it4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-curl-时间变量格式化输出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/curl-时间变量格式化输出/" class="article-date">
  <time datetime="2017-09-13T08:34:11.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/curl-时间变量格式化输出/">curl 时间变量格式化输出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 对curl时间变量的格式化输出。<br>定义格式化文件</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>#vim  curl-format.txt<br>\n<br>            time_namelookup:  %{time_namelookup}\n<br>               time_connect:  %{time_connect}\n<br>            time_appconnect:  %{time_appconnect}\n<br>           time_pretransfer:  %{time_pretransfer}\n<br>              time_redirect:  %{time_redirect}\n<br>         time_starttransfer:  %{time_starttransfer}\n<br>                            ———-\n<br>                 time_total:  %{time_total}\n<br>\n<br>这些变量的含义不解释了，大伙去看看curl帮助文档。重点说下time_connect和time_appconnect变量。time_connect 变量表示 TCP 握手的耗时，time_appconnect 变量表示 SSL 握手的耗时（ssl延时）。HTTPs 连接耗时要比 HTTP 连接耗时长 3 倍左右，具体取决于 CPU 的快慢。<br>发送请求</p>
<h1 id="curl-w-“-curl-format-txt”-o-dev-null-s-http-www-baidu-com"><a href="#curl-w-“-curl-format-txt”-o-dev-null-s-http-www-baidu-com" class="headerlink" title="curl -w “@curl-format.txt” -o /dev/null -s  http://www.baidu.com"></a>curl -w “@curl-format.txt” -o /dev/null -s  <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></h1><pre><code>   time_namelookup:  0.002
      time_connect:  1.973
   time_appconnect:  0.000
  time_pretransfer:  1.973
     time_redirect:  0.000
time_starttransfer:  3.126
                   ----------
        time_total:  5.374
</code></pre><h1 id="curl-w-“-curl-format-txt”-o-dev-null-s-https-www-baidu-com"><a href="#curl-w-“-curl-format-txt”-o-dev-null-s-https-www-baidu-com" class="headerlink" title="curl -w “@curl-format.txt” -o /dev/null -s  https://www.baidu.com"></a>curl -w “@curl-format.txt” -o /dev/null -s  <a href="https://www.baidu.com" target="_blank" rel="external">https://www.baidu.com</a></h1><pre><code>   time_namelookup:  0.003
      time_connect:  1.705
   time_appconnect:  4.007
  time_pretransfer:  4.007
     time_redirect:  0.000
time_starttransfer:  5.214
                   ----------
        time_total:  5.214
</code></pre><p>-w 指定格式化文件<br>-o 请求重定向到<br>-s 静默，不显示进度</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/curl-时间变量格式化输出/" data-id="cj7iup5g80001xp5wk29nkl3b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx配置陷阱和常见错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/nginx配置陷阱和常见错误/" class="article-date">
  <time datetime="2017-09-13T08:31:20.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/nginx配置陷阱和常见错误/">nginx配置陷阱和常见错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新老用户都可能遇到陷阱。下面我们列出频繁出现的问题，以及如何解决。 在 Freenode IRC #nginx 频道，我们经常看到这些问题。</p>
<p>关于本指南<br>最常见的是有人试图从其他指南拷贝配置片段。并非所有的指南是错误的，但绝大部分是有问题的。 甚至 Linode library 的质量也不高，NGINX 社区成员有义务去尝试更正。</p>
<p>这些文档由社区成员创建并审核。存在该指南的意义在于社区成员常见及反复出现的问题。</p>
<p>我的问题未列出<br>你遇到的问题在这里没有看到，也许我们在这里没有指明你经历的问题。不要以为你无缘无故的浏览到该 页面，你看到这些是因为你做错的事情列在这里。</p>
<p>当涉及到支持许多用户的很多问题，社区成员不想去支持未遵守约定的配置。通过阅读以下指南，修复你的配置。</p>
<p>Chmod 777<br>绝不使用 777。它可能是个漂亮的号码，即使在测试中也表现的你没有任何线索在做什么。在整个路径中 查看权限，想想会发生什么。</p>
<p>轻松的显示路径权限，可以使用：</p>
<p>namei -om /path/to/check<br>Root 在 Location 区块<br>BAD</p>
<p>server {<br>    server_name www.example.com;<br>    location / {<br>        root /var/www/nginx-default/;</p>
<pre><code>    # [...]
  }
location /foo {
    root /var/www/nginx-default/;
    # [...]
}
location /bar {
    root /var/www/nginx-default/;
    # [...]
}
</code></pre><p>}<br>这有效。把root放在location区块可以生效而且完全有效。错误之处在于开始添加location区块， 如果你在每个location区块添加root指令，没有匹配location区块将没有root。下面看看正确的配置。</p>
<p>GOOD</p>
<p>server {<br>    server_name www.example.com;<br>    root /var/www/nginx-default/;<br>    location / {</p>
<pre><code>    # [...]
}
location /foo {
    # [...]
}
location /bar {
    # [...]
}
</code></pre><p>}<br>多重 Index 指令<br>BAD</p>
<p>http {<br>    index index.php index.htm index.html;<br>    server {<br>        server_name www.example.com;<br>        location / {<br>            index index.php index.htm index.html;</p>
<pre><code>        # [...]
    }
}
server {
    server_name example.com;
    location / {
        index index.php index.htm index.html;
        # [...]
    }
    location /foo {
        index index.php;
        # [...]
    }
}
</code></pre><p>}<br>为什么在不需要时重复那么多行。简单的使用一次 “index” 指令。仅仅需要添加到http{}区块，将会被继承。</p>
<p>GOOD</p>
<p>http {<br>    index index.php index.htm index.html;<br>    server {<br>        server_name www.example.com;<br>        location / {</p>
<pre><code>        # [...]
    }
}
server {
    server_name example.com;
    location / {
        # [...]
    }
    location /foo {
        # [...]
    }
}
</code></pre><p>}<br>使用 If<br>有几个页面介绍使用 if 语句。它叫做IfIsEvil，你真的应该看看。让我们看看使用 if 的坏处。</p>
<p>See also</p>
<p>If Is Evil</p>
<p>Server Name (if)<br>BAD</p>
<p>server {<br>    server_name example.com <em>.example.com;<br>        if ($host ~</em> ^www.(.+)) {<br>            set $raw_domain $1;<br>            rewrite ^/(.*)$ $raw_domain/$1 permanent;<br>        }</p>
<pre><code>    # [...]
}
</code></pre><p>}<br>这里有3个问题。第一个是if，我们关心的。当 NGINX 接受一个请求不管是子域名 www.example.com 还是 example.com，if指令总是会判断。因为你要求 NGINX 检查每个请求的 Host 头。 这样效率低下，你应该避免。像下面一样使用2个server指令。</p>
<p>GOOD</p>
<p>server {<br>    server_name www.example.com;<br>    return 301 $scheme://example.com$request_uri;<br>}<br>server {<br>    server_name example.com;</p>
<pre><code># [...]
</code></pre><p>}<br>除了配置文件更易于阅读，这种方法减少 NGINX 处理需求。我们摆脱了虚假的if，同时使用 $scheme,没有硬编码 URI 的结构，可以是 http 或者 https。</p>
<p>检查文件 (if) 存在<br>使用 if 去检查文件是否存在是糟糕的。如果你使用最新版本的 NGINX ，应该看看try_files,更 易使用。</p>
<p>BAD</p>
<p>server {<br>    root /var/www/example.com;<br>    location / {<br>        if (!-f $request_filename) {<br>            break;<br>        }<br>    }<br>}<br>GOOD</p>
<p>server {<br>    root /var/www/example.com;<br>    location / {<br>        try_files $uri $uri/ /index.html;<br>    }<br>}<br>这里我们判断$uri是否存在不再需要if。使用try_files意味着可以依序测试。 如果$uri不存在，尝试$uri/，如果还不存在，尝试备用的location。</p>
<p>在这个案例中，会先查看$uri文件是否存在，存在就返回。如果不存在，就检查该目录是否存在。 如果不存在，将返回index.html,你必须确定存在该文件。</p>
<p>Front Controller 模式 WEB 应用<br>“Front Controller 模式”设计是受欢迎的，且用在许多最流行的 PHP 软件包中。 很多实例比应有的更复杂。让 Drupal, Joomla 等运行，使用：</p>
<p>try_files $uri $uri/ /index.php?q=$uri&amp;$args;<br>注解 - 参数名称根据你使用的包是不同的。例如</p>
<p>“q” 是 Drupal、Joomla、WordPress 使用的参数<br>“page” 是 CMS Made Simple 使用的参数<br>一些软件甚至不用查询字符串，而且可以从REQUEST_URI读取（WordPress支持，例如）：</p>
<p>try_files $uri $uri/ /index.php;<br>当然你的情况可能不同，你可能根据需求添加复杂的规则，但一个基本的网站，这些将完美的工作。 你可以从简单的开始。</p>
<p>如果你不在乎目录是否存在，你也可以决定跳过目录检查，从中删除$uri/。</p>
<p>把不受控制的请求给 PHP<br>很多对 PHP 的 NGINX 配置样例把每个以.php结尾的 URI 给 PHP 解释器。请注意在大多数 PHP 设置中，这将是个严重的安全问题，因为它允许任意第三方代码执行。</p>
<p>出问题的区域通常如下：</p>
<p>location ~* .php$ {<br>    fastcgi_pass backend;</p>
<pre><code># [...]
</code></pre><p>}<br>这里每一个以.php结尾文件的请求将会给FastCGI后端。 这里的问题是如果全路径并不指向文件系统上实际的文件，默认的 PHP 配置会试图猜测你需要执行哪个文件。</p>
<p>例如，如果请求不存在的文件/forum/avatar/1232.jpg/file.php，但/forum/avatar/1232.jpg存在， PHP 解释器将处理/forum/avatar/1232.jpg。如果它包含 PHP 代码，这段代码将相应的执行。</p>
<p>下面的选项可以避免上述情况：</p>
<p>在php.ini中设置cgi.fix_pathinfo=0。使得 PHP 解释器仅尝试给出的路径，如果文件没有找到就停止处理。<br>保证 NGINX 仅传给后端指定的 PHP 文件请求：<br>location ~* (file_a|file_b|file_c).php$ {<br>    fastcgi_pass backend;</p>
<pre><code># [...]
</code></pre><p>}<br>特别地在任何包含用户上传的目录中禁用 PHP 文件的执行<br>location /uploaddir {<br>    location ~ .php$ {return 403;}</p>
<pre><code># [...]
</code></pre><p>}<br>使用try_files指令过滤<br>location ~* .php$ {<br>    try_files $uri =404;<br>    fastcgi_pass backend;</p>
<pre><code># [...]
</code></pre><p>}<br>使用嵌套的 location 过滤<br>location ~<em> .php$ {<br>    location ~ ..</em>/.*.php$ {return 404;}<br>    fastcgi_pass backend;</p>
<pre><code># [...]
</code></pre><p>}<br>Script Filename 中的 FastCGI Path<br>一些指南倾向使用绝对路径得到信息。这在 PHP 区块很常见。当你从源安装 NGINX ，通常你能够把 include fastcgi_params;加入到配置中。该文件通常在 NGINX 配置目录/etc/nginx/。</p>
<p>GOOD</p>
<p>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;<br>BAD</p>
<p>fastcgi_param  SCRIPT_FILENAME    /var/www/yoursite.com/$fastcgi_script_name;<br>$document_root在哪里设置？是通过 root 指令在 server 区块设置。root 指令没有配置？看看 第一个陷阱。</p>
<p>繁杂的 Rewrites<br>不要感觉糟糕，正则表达式容易让人困惑。实际上，我们应该努力保持整洁、简单，不增加繁琐的东西，这容易做到。</p>
<p>BAD</p>
<p>rewrite ^/(.*)$ <a href="http://example.com/$1" target="_blank" rel="external">http://example.com/$1</a> permanent;<br>GOOD</p>
<p>rewrite ^ <a href="http://example.com$request_uri?" target="_blank" rel="external">http://example.com$request_uri?</a> permanent;<br>BETTER</p>
<p>return 301 <a href="http://example.com$request_uri" target="_blank" rel="external">http://example.com$request_uri</a>;<br>第一个 rewrite 捕获在第一个/之后的 URI。通过使用内建变量$request_uri，我们可以有效的避免做任何捕获或者匹配。</p>
<p>Rewrite 丢失 http://<br>rewrite 是简单，记得添加scheme。</p>
<p>BAD</p>
<p>rewrite ^ example.com permanent;<br>GOOD</p>
<p>rewrite ^ <a href="http://example.com" target="_blank" rel="external">http://example.com</a> permanent;<br>在上面可以看到，我们在 rewrite 添加了<a href="http://。简单有效。" target="_blank" rel="external">http://。简单有效。</a></p>
<p>代理一切<br>BAD</p>
<p>server {<br>    server<em>name </em>;<br>    root /var/www/site;<br>    location / {<br>        include fastcgi_params;<br>        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>        fastcgi_pass unix:/tmp/phpcgi.socket;<br>    }<br>}<br>令人讨厌的，在这种情况下把所有的请求都给 PHP 处理。为什么？Apache 也许是这样做，但你不必。让我这么说吧… try_files指令存在的原因，它按特定的顺序尝试文件。意味着 NGINX 可以先尝试提供静态内容。如果不能，继续尝试。 这样 PHP 根本不参与，快的多。特别是如果你通过 PHP 提供 1MB 图片的时间是直接提供的1000倍，让我们看看该怎么做。</p>
<p>GOOD</p>
<p>server {<br>    server<em>name </em>;<br>    root /var/www/site;<br>    location / {<br>        try_files $uri $uri/ @proxy;<br>    }<br>    location @proxy {<br>        include fastcgi_params;<br>        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>        fastcgi_pass unix:/tmp/phpcgi.socket;<br>    }<br>}<br>Also GOOD</p>
<p>server {<br>    server<em>name </em>;<br>    root /var/www/site;<br>    location / {<br>        try_files $uri $uri/ /index.php;<br>    }<br>    location ~ .php$ {<br>        include fastcgi_params;<br>        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>        fastcgi_pass unix:/tmp/phpcgi.socket;<br>    }<br>}<br>很简单，是不是？如果请求的 URI 存在，NGINX 直接提供。如果不存在，检查目录是否存在。如果不存在，传递给你的代理。 只有当 NGINX 不能直接服务请求的 URI，你的代理将参与开销。</p>
<p>现在想想你的多少请求是静态资源，比如 images、css、javascript 等。你可能节省很多开销。</p>
<p>配置更改没有生效<br>浏览器缓存。你的配置也许是很棒的，但你会坐在那，撞墙一个月。问题出在你的浏览器缓存。 当你下载了东西，你的浏览器会保存下来。同时也保存了文件是如何提供的。如果你配置有 types 区块，你会遇到这情况。</p>
<p>处理方法：</p>
<p>在 Firefox 浏览器中按 Ctrl+Shift+Delete，检查缓存，点击 Clear Now。其他浏览器，可搜索下方法。 每次更改之后都清除下，会为你节省不少麻烦。<br>使用 curl。<br>VirtualBox<br>如果这不起作用,而且你在 VirtualBox 中的虚拟机中运行 NGINX，也许是sendfile()引起的问题。 简单的注释掉sendfile指令，或者设置为“off”。</p>
<p>sendfile off;<br>缺失的 HTTP 头<br>如果你没有明确的设置underscores_in_headers on，NGINX 将会默默地忽略掉带有下划线的头信息（根据 HTTP 标准是完全有效的）。 这样做为了防止头信息映射到 CGI 变量过程中破折号和下划线都映射成下划线引起歧义。</p>
<p>没有使用标准的 Document Root Locations<br>有些目录在任何文件系统中不应该用于托管数据。其中包括/和/root。你不应该使用这些作为网站根目录。</p>
<p>这样作让你的隐私数据毫无预期的返回给请求。</p>
<p>永远不要这样做！！！</p>
<p>server {<br>    root /;</p>
<pre><code>location / {
    try_files /web/$uri $uri @php;
}

location @php {
    # [...]
}
</code></pre><p>}<br>当一个请求/foo，因为文件找不到将代理到 php 。这看起来正常，直到请求/etc/passwd。是的，你给了服务器上所有用户列表。 在某些情况下，Nginx 服务器进程被设置以 root 用户运行。是的，我们现在有你的用户列表以及密码 hash 密码，以及如何 hash 的。</p>
<p>文件系统层级标准定义了数据应该存在哪里。你应该看看。 简而言之，你的 web 内容可以存放在/var/www/、/srv、/usr/share/www。</p>
<p>使用默认的 Document Root<br>Ubuntu、Debian 等其他操作系统中NGINX包，作为易于安装的包会提供默认的配置文件用作一个例子，而且会包含网站根目录存储基本的 HTML 文件。</p>
<p>多数系统包不检查默认的Document Root中文件是否存在或者修改。这样会在软件包升级时导致代码丢失。经验丰富的系统管理员没有期望在 升级期间默认的document root内容保持不变。</p>
<p>你不应该对将网站的关键文件使用默认的document root。在你的系统升级或者更新 NGINX 包时有很大可能性会导致默认的document root 内容会改变。</p>
<p>使用 Hostname 去解析地址<br>BAD</p>
<p>upstream {<br>    server <a href="http://someserver" target="_blank" rel="external">http://someserver</a>;<br>}</p>
<p>server {<br>    listen myhostname:80;</p>
<pre><code># [...]
</code></pre><p>}<br>你不应该在 listen 指令中使用 hostname。也许这样有效，也将会有大量的问题。 其中一个问题是在服务启动或者重启时 hostname 不能解析。这会引起 NGINX 无法绑定到特定的 TCP 端口，最终 NGINX 启动失败。</p>
<p>更安全的做法是知道需要绑定的 IP 地址，并使用 IP 而不是 hostname。 阻止 NGINX 需要查找 IP ，不依赖内部或者外部的解析。</p>
<p>upstream 区块也有同样的问题。并不是总要在 upstream 区块避免使用 hostname，这不是好的做法，使用时要考虑清楚。</p>
<p>GOOD</p>
<p>upstream {<br>    server <a href="http://10.48.41.12" target="_blank" rel="external">http://10.48.41.12</a>;<br>}</p>
<p>server {<br>    listen 127.0.0.16:80;</p>
<pre><code># [...]
</code></pre><p>}<br>HTTPS 中使用 SSLv3¶<br>由于 SSLv3 的POODLE漏洞，建议在 SSL 的网站不启用 SSLv3。你可以很简单的禁用 SSLv3，只提供 TLS 协议。</p>
<p>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/nginx配置陷阱和常见错误/" data-id="cj7iup5ge0004xp5wpxgbuip7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-这20个正则表达式，让你少写1-000行代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/13/这20个正则表达式，让你少写1-000行代码/" class="article-date">
  <time datetime="2017-09-13T08:29:01.000Z" itemprop="datePublished">2017-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/13/这20个正则表达式，让你少写1-000行代码/">这20个正则表达式，让你少写1,000行代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。<br>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<p>var reg = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert(‘Date format error!’);<br>下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。</p>
<p>1 . 校验密码强度</p>
<p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<p>^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$</p>
<ol>
<li>校验中文</li>
</ol>
<p>字符串仅能是中文。</p>
<p>^[\u4e00-\u9fa5]{0,}$</p>
<ol>
<li>由数字、26个英文字母或下划线组成的字符串</li>
</ol>
<p>^\w+$</p>
<ol>
<li>校验E-Mail 地址</li>
</ol>
<p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<p>[\w!#$%&amp;’<em>+/=?^_`{|}~-]+(?:\.[\w!#$%&amp;’</em>+/=?^_`{|}~-]+)<em>@(?:[\w](?:[\w-]</em>[\w])?\.)+<a href="?:[\\w-]*[\\w]">\w</a>?</p>
<ol>
<li>校验身份证号码</li>
</ol>
<p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<p>^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$<br>18位：</p>
<p>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$</p>
<ol>
<li>校验日期</li>
</ol>
<p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<p>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</p>
<ol>
<li>校验金额</li>
</ol>
<p>金额校验，精确到2位小数。</p>
<p>^[0-9]+(.[0-9]{2})?$</p>
<ol>
<li>校验手机号</li>
</ol>
<p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<p>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</p>
<ol>
<li>判断IE的版本</li>
</ol>
<p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<p>^.<em>MSIE <a href="?:\\.[0-9]+">5-8</a>?(?!.</em>Trident\/[5-9]\.0).*$</p>
<ol>
<li>校验IP-v4地址</li>
</ol>
<p>IP4 正则语句。</p>
<p>\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b</p>
<ol>
<li>校验IP-v6地址</li>
</ol>
<p>IP6 正则语句。</p>
<p>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</p>
<ol>
<li>检查URL的前缀</li>
</ol>
<p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<p>if (!s.match(/^[a-zA-Z]+:\/\//)){ s = ‘http://‘ + s;}</p>
<ol>
<li>提取URL链接</li>
</ol>
<p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<p>^(f|ht){1}(tp|tps):\/\/([\w-]+\.)+[\w-]+(\/[\w- ./?%&amp;=]*)?</p>
<ol>
<li>文件路径及扩展名校验</li>
</ol>
<p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<p>^([a-zA-Z]\:|\\)\\([^\\]+\\)<em>[^\/:</em>?”&lt;&gt;|]+\.txt(l)?$</p>
<ol>
<li>提取Color Hex Codes</li>
</ol>
<p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<p>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</p>
<ol>
<li>提取网页图片</li>
</ol>
<p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<p>\&lt; <em>[img][^\\&gt;]</em>[src] <em>= </em>[\“\‘]{0,1}([^\“\‘\ &gt;]*)</p>
<ol>
<li>提取页面超链接</li>
</ol>
<p>提取html中的超链接。</p>
<p>(<a\\s*(?!.*\\brel=)[^>]<em>)(href=”https?:\/\/)((?!(?:(?:www\.)?’.implode(‘|(?:www\.)?’, $follow_list).’))[^”]+)”((?!.</em>\brel=)[^&gt;]<em>)(?:[^&gt;]</em>)&gt;</a\\s*(?!.*\\brel=)[^></p>
<ol>
<li>查找CSS属性</li>
</ol>
<p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p>
<p>^\s<em>[a-zA-Z\-]+\s</em>[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1}</p>
<ol>
<li>抽取注释</li>
</ol>
<p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<!--(.*?)-->
<ol>
<li>匹配HTML标签</li>
</ol>
<p>通过下面的表达式可以匹配出HTML中的标签属性。</p>
<p>&lt;\/?\w+((\s+\w+(\s<em>=\s</em>(?:”.<em>?”|’.</em>?’|[\^’”&gt;\s]+))?)+\s<em>|\s</em>)\/?&gt;<br>正则表达式的相关语法</p>
<p>下面是我找到的一张非常不错的正则表达式 Cheat Sheet，可以用来快速查找相关语法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://silverfox2016.github.com/2017/09/13/这20个正则表达式，让你少写1-000行代码/" data-id="cj7iup5gt000dxp5w8gkm95ya" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/13/让man看起来色彩更加绚丽/">让man看起来色彩更加绚丽</a>
          </li>
        
          <li>
            <a href="/2017/09/13/nginx正则说明/">nginx正则说明</a>
          </li>
        
          <li>
            <a href="/2017/09/13/rsync-log日志时间差8小时问题/">rsync log日志时间差8小时问题</a>
          </li>
        
          <li>
            <a href="/2017/09/13/终极Web应用性能和压力测试工具Gor/">终极Web应用性能和压力测试工具Gor</a>
          </li>
        
          <li>
            <a href="/2017/09/13/高效用Google/">高效用Google</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 silverfox2016<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>